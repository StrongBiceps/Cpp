# Cpp

# 2023.09.12

# char pointer array

문자열 배열에 대한 코드이다. 

const char* ptr[3] = { "rabbit","tiger","cow" };

cout << (int)ptr << endl;
 
cout << (int)&ptr[0] << endl;
 
cout << (int)ptr[0] << endl;

-(int)ptr은 배열의 주소를 의미하는 ptr을 정수형으로 캐스팅하여 출력하는 것이다.

-(int)&ptr[0]는 []연산자로 한 차원을 참조한 뒤 주소 연산자를 사용하고 있다. 따라서 첫 번째 메모리 공간에 저장된 값이 저장된 공간을 의미한다. 즉 첫 번째 메모리 공간의 주소를 의미하는 것이다. 
그 값은 ptr, 즉 배열 ptr의 시작 주소이다. 따라서 위 값과 같은 정수가 출력될 것이다.

-(int)ptr[0]는 []연산자로 한 차원을 참조한 것이다. 따라서 ptr의 첫 번째 메모리 공간에 저장된 값을 의미한다. 그 안에 저장된 값은 "rabbit" = 문자열 시작 주소이다. 따라서 rabbit의 시작 주소가
정수형으로 캐스팅되어 출력된다. 

[]로 한 차원씩 참조하는 것을 잘 유의해서 분석해야 한다.

# Two Dimentional Dynamic Array

1차원 동적 배열을 포인터 배열에 동적할당한 경우는 2차원 동적 배열이 생성된다. 이 2차원 배열의 주소는 2 포인터이다. 

int** Two_d_array = new int* [row] {row_1, row_2, row_3};

int** temp = Two_d_array+1;

int* 형을 저장할 수 있는 방 3개로 구성된 배열이다. 1차원 포인터의 주소를 저장할 수 있는 자료형은 2중 포인터이다.

위 배열은 int*형 메모리의 첫 번째 주소를 의미한다. 따라서 포인터를 가리킬 수 있는 자료형은 2차원 포인터이다.

1차원 포인터가 저장하고 있는 값은 1차원 포인터의 주소가 아니라 가리키고 있는 값의 주소이다. 포인터 그 자체의 주소는 &연산자를 통해 구할 수 있다.

서로 가리키고 있는 값의 주소를 대입할 수 있는 것과 포인터를 가리키는 것을 구별해야 한다.

int *p = Pointer; //정수형 값의 주소를 대입하는 것.

int **p = &p //2중 포인터에 1차원 포인터의 주소를 대입

아래 코드는 가능할까?

int *p = new int* [row];

잘 생각해보면 int* 배열의 시작 주소는 int형 포인터가 가리키는 값이 아니라 int형 포인터의 주소이다. 따라서 int형 포인터의 주소를 대입할 수 있는 자료형은 2중 포인터 뿐이므로
불가능한 코드이다.
# Conditional_Compilation (조건부 컴파일)

*조건부 컴파일을 위한 지시자

#if #elif #else #endif문은 조건부 컴파일을 위한 지시자로서, 특정 조건이 만족하면 컴파일 작업을 수행하고 그렇지 않으면 컴파일을 수행하지 않도록 할 때 사용한다.

#ifdef문은 특정 매크로가 정의되어 있는지를 물어본다. #ifndef문은 if not define을 줄여서 만든 문장이므로 특정 매크로가 정의되어 있지 않았는지를 물어 볼 때 사용한다. 다음은 #ifdef문, #ifndef문을 사용한 프로그램이다.

* #undef
* 
#undef는 #define과 반대의 역할을 하는 것으로 이미 정의된 기호 상수를 취소시켜 정의되지 않은 상태로 만들고자 할 때 사용한다.

#define SIZE 10

I=SIZE;

#define SIZE 20

J=SIZE;

위 코드에서 SIZE를 두 번 정의할 수 없으므로 오류가 난다. 이럴 때 undef를 사용한다.

#define SIZE 10

I=SIZE;

#undef SIZE

#define SIZE 20

j=SIZE;

# erase_remove Idiom

erase함수는 여러 원소를 한 번에 지울 수 없다. 따라서 n개의 원소를 지우기 위해서는 O(n) 시간에 대해서 n번 순회해야 한다. 하지만 remove는 한 번의 순회로 조건에 맞는 원소들에 대해 인덱스 연산을 하기 때문에 O(n) 소요된다. 즉 erase는 O(n^2)이고 remove idiom을 사용하면 한 번의 순회로 조건에 맞는 원소들을 뒤로 밀어 넣고 한 번에 삭제하면 성능에 이점을 얻을 수 있다.

# Conversion_Constructor ( 변환 생성자 )

변환 생성자는 클래스의 객체를 초기화하는데 사용되는 특별한 종류의 생성자이다. 변환 생성자는 단일 매개변수를 가지며, 이 매개변수가 해당 클래스 타입이 아닌 다른 타입을 가진다. 이러한 특성 덕분에 변환 생성자는 한 타입에서 다른 클래스 타입으로 암시적으로 변환하는 데 사용될 수 있다. 하지만 의도치 않은 동작을 할 수 있기 때문에 explicit 키워드를 사용하여 암시적 변환을 방지할 수 있다.

# Static Member

클래스의 정적 멤버 함수는 객체의 존재와 관계 없이 외부에서 호출할 수 있다. 따라서 특정 객체에 종속적인 멤버에 접근할 수 없고 호출할 수도 없다. 단, 정적 멤버 변수나 함수는 호출과 접근이 가능하다.

# non-inherited member

C++에서 클래스를 상속하면 대부분의 멤버가 파생 클래스로 상속됩니다. 하지만 아래 목록의 항목들은 상속되지 않는다.

생성자 (Constructors)

소멸자 (Destructor)

복사 생성자 (Copy constructor)

이동 생성자 (Move constructor)

복사 대입 연산자 (Copy assignment operator)

이동 대입 연산자 (Move assignment operator)

이들은 각각의 클래스가 고유하게 가져야하는 기능들이기 때문에 상속되지 않는다.

또한, private 멤버도 상속은 되지만 직접 접근할 수 없으므로 파생 클래스에서 사용할 수 없다.

그 외에 friend 선언도 상속되지 않는다. 즉, 베이스 클래스가 어떤 함수나 클래스를 friend로 선언했다고 해서 그것이 파생 클래스에 자동으로 적용되는 것은 아니다.

마지막으로, 기본 클래스에서 템플릿 인스턴스화는 파생된 클래스로 전달되거나 "상속"되지 않는다.

정적 멤버는 상속된다.

# 2023.09.13

# Pure_Virtual_Function

추상 클래스인 기반 클래스 A로부터 상속받은 클래스 B가 있다고 가정한다.

A에서 virtual void print() = 0 이라는 순수 가상 함수를 정의하고 있다. 여기서 공통으로 이루어져야 하는 작업이 있다면 순수 가상 함수의 몸체를 구현할 수 있다.

virtual void print() = 0

{

cout<<"기반 클래스에서 미리 구현"<<endl;

}

파생 클래스에서는 해당 기반 클래스 순수 가상 함수를 재정의한 후, 몸체 안에서 기반 클래스 버전을 호출하면 된다.

# Lambda Expression

람다 표현식은 작성이 간편하고 가독성에서 이점이 있다. 또한 인라인 최적화되어 있어 동작 속도가 빠르다. 

# 2023.09.14

# Member_pointer

멤버 포인터는 클래스 멤버를 가리킬 수 있는 포인터이다. 단, 레퍼런스 멤버와 정적 멤버는 가리킬 수 없다.

# Reference, const class member

클래스 내부에 레퍼런스 변수와 상수가 존재한다면 컴파일러는 디폴트 대입 연산자를 제공하지 않는다. 하지만 사용자가 대입 연산자를 오버로딩한다면 사용이 가능하다.
레퍼런스에 새로운 값을 대입하는 것도 가능하다. 단, 상수의 경우에는 초기화 이후에 수정이 불가능하므로 대입 연산자를 오버로딩해도 값을 바꿀 수는 없다.

# ptr_fun (function pointer adpater)

일반 함수를 함수 객체로 포장하는 ptr_fun의 사용법에 대해서 알아본다.

# mem_fun (member function pointer adapter)

클래스 내의 멤버 함수를 함수 객체로 포장하는 mem_fun의 사용법에 대해서 알아본다.

# std::set, std:map 

Red-Black Tree 기반의 set과 map을 알아본다. set과 map은 중복 키를 허용하지 않는다. set은 키 값만을 저장하고, map은 키를 기준으로 정렬하고 키와 값 쌍을 저장한다.
Red-Black Tree 기반이기 때문에 검색과 삽입이 빠른 편이다. 해시 기반 컨테이너인 unordered_set,unordered_map 보다는 느리다. 하지만 해시 기반 컨테이너들은 메모리를
많이 사용한다는 단점이 존재한다. multiset과 multimap은 중복을 허용한다. 이 두 컨테이너 또한 Red-Black Tree로 이루어져 있다.
