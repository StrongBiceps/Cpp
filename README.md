# Cpp

# 2023.09.12

# char pointer array

문자열 배열에 대한 코드이다. 

const char* ptr[3] = { "rabbit","tiger","cow" };

cout << (int)ptr << endl;
 
cout << (int)&ptr[0] << endl;
 
cout << (int)ptr[0] << endl;

-(int)ptr은 배열의 주소를 의미하는 ptr을 정수형으로 캐스팅하여 출력하는 것이다.

-(int)&ptr[0]는 []연산자로 한 차원을 참조한 뒤 주소 연산자를 사용하고 있다. 따라서 첫 번째 메모리 공간에 저장된 값이 저장된 공간을 의미한다. 즉 첫 번째 메모리 공간의 주소를 의미하는 것이다. 
그 값은 ptr, 즉 배열 ptr의 시작 주소이다. 따라서 위 값과 같은 정수가 출력될 것이다.

-(int)ptr[0]는 []연산자로 한 차원을 참조한 것이다. 따라서 ptr의 첫 번째 메모리 공간에 저장된 값을 의미한다. 그 안에 저장된 값은 "rabbit" = 문자열 시작 주소이다. 따라서 rabbit의 시작 주소가
정수형으로 캐스팅되어 출력된다. 

[]로 한 차원씩 참조하는 것을 잘 유의해서 분석해야 한다.

# Two Dimentional Dynamic Array

1차원 동적 배열을 포인터 배열에 동적할당한 경우는 2차원 동적 배열이 생성된다. 이 2차원 배열의 주소는 2 포인터이다. 

int** Two_d_array = new int* [row] {row_1, row_2, row_3};

int** temp = Two_d_array+1;

int* 형을 저장할 수 있는 방 3개로 구성된 배열이다. 1차원 포인터의 주소를 저장할 수 있는 자료형은 2중 포인터이다.

위 배열은 int*형 메모리의 첫 번째 주소를 의미한다. 따라서 포인터를 가리킬 수 있는 자료형은 2차원 포인터이다.

1차원 포인터가 저장하고 있는 값은 1차원 포인터의 주소가 아니라 가리키고 있는 값의 주소이다. 포인터 그 자체의 주소는 &연산자를 통해 구할 수 있다.

서로 가리키고 있는 값의 주소를 대입할 수 있는 것과 포인터를 가리키는 것을 구별해야 한다.

int *p = Pointer; //정수형 값의 주소를 대입하는 것.

int **p = &p //2중 포인터에 1차원 포인터의 주소를 대입

아래 코드는 가능할까?

int *p = new int* [row];

잘 생각해보면 int* 배열의 시작 주소는 int형 포인터가 가리키는 값이 아니라 int형 포인터의 주소이다. 따라서 int형 포인터의 주소를 대입할 수 있는 자료형은 2중 포인터 뿐이므로
불가능한 코드이다.
# Conditional_Compilation (조건부 컴파일)

*조건부 컴파일을 위한 지시자

#if #elif #else #endif문은 조건부 컴파일을 위한 지시자로서, 특정 조건이 만족하면 컴파일 작업을 수행하고 그렇지 않으면 컴파일을 수행하지 않도록 할 때 사용한다.

#ifdef문은 특정 매크로가 정의되어 있는지를 물어본다. #ifndef문은 if not define을 줄여서 만든 문장이므로 특정 매크로가 정의되어 있지 않았는지를 물어 볼 때 사용한다. 다음은 #ifdef문, #ifndef문을 사용한 프로그램이다.

* #undef
* 
#undef는 #define과 반대의 역할을 하는 것으로 이미 정의된 기호 상수를 취소시켜 정의되지 않은 상태로 만들고자 할 때 사용한다.

#define SIZE 10

I=SIZE;

#define SIZE 20

J=SIZE;

위 코드에서 SIZE를 두 번 정의할 수 없으므로 오류가 난다. 이럴 때 undef를 사용한다.

#define SIZE 10

I=SIZE;

#undef SIZE

#define SIZE 20

j=SIZE;

# erase_remove Idiom

erase함수는 여러 원소를 한 번에 지울 수 없다. 따라서 n개의 원소를 지우기 위해서는 O(n) 시간에 대해서 n번 순회해야 한다. 하지만 remove는 한 번의 순회로 조건에 맞는 원소들에 대해 인덱스 연산을 하기 때문에 O(n) 소요된다. 즉 erase는 O(n^2)이고 remove idiom을 사용하면 한 번의 순회로 조건에 맞는 원소들을 뒤로 밀어 넣고 한 번에 삭제하면 성능에 이점을 얻을 수 있다.

# Conversion_Constructor ( 변환 생성자 )

변환 생성자는 클래스의 객체를 초기화하는데 사용되는 특별한 종류의 생성자이다. 변환 생성자는 단일 매개변수를 가지며, 이 매개변수가 해당 클래스 타입이 아닌 다른 타입을 가진다. 이러한 특성 덕분에 변환 생성자는 한 타입에서 다른 클래스 타입으로 암시적으로 변환하는 데 사용될 수 있다. 하지만 의도치 않은 동작을 할 수 있기 때문에 explicit 키워드를 사용하여 암시적 변환을 방지할 수 있다.
